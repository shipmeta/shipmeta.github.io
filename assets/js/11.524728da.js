(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{368:function(n,e,s){"use strict";s.r(e);var t=s(42),a=Object(t.a)({},(function(){var n=this,e=n.$createElement,s=n._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h1",{attrs:{id:"ship-node"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ship-node"}},[n._v("#")]),n._v(" Ship-Node")]),n._v(" "),s("h2",{attrs:{id:"一、安装及配置nodejs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、安装及配置nodejs"}},[n._v("#")]),n._v(" 一、安装及配置nodejs")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('>>下载：http://nodejs.cn/\n>>根据系统下载对应版本后直接运行安装\n>>便于管理建议安装到自定义路劲，此处为：【D:\\Work\\CodeLang\\NodeJs】\n>>安装完成后cmd运行：\n\tnode -v \n\tnpm -v\n\tyarn -v\n>>如果没有yarn: \n\tnpm install -g yarn >> yarn -v \n>>如果提示无法找到内部命令：\n\twhere yarn >> 将路劲添加到path环境变量即可：【C:\\Users\\vic\\AppData\\Roaming\\npm\\node_modules\\yarn\\bin】\n>>切换淘宝镜像 \n\tyarn config set registry https://registry.npm.taobao.org\n>>配置全局路劲：安装目录下新建目录【node_cache】和【node_global】\n\tnpm config set cache  "D:\\Work\\CodeLang\\NodeJs\\node_cache"\n\tnpm config set prefix "D:\\Work\\CodeLang\\NodeJs\\node_global"\n\tyarn config set global-folder "D:\\Work\\CodeLang\\NodeJs\\node_global"\t\n\tyarn config set cache-folder "D:\\Work\\CodeLang\\NodeJs\\node_cache"\t\n>>添加系统环境变量：\n\tpath：【D:\\Work\\CodeLang\\NodeJs\\node_global】\n\tNODE_PATH：【D:\\Work\\CodeLang\\NodeJs\\node_global】\n>>安装webpack：\n\tnpm install webpack -gD\n\tnpm install webpack-cli -gD\n\tyarn add webpack -gD\n\tyarn add webpack webpack-cli -gD\n>>安装指定版本：\n\tnpm install webpack@<version> -g        \n>>例如：\n\tnpm install  webpack@4.41.2  -g\n>>查看版本：\n\twebpack -v\n>>在全局下删除:\n\tnpm uninstall webpack -g\n>>局部删除:\n\tnpm uninstall webpack\n>>至此安装及配置完成。\n>>【注意：】\n\t对于git管理的项目：git push到github需要忽略的文件请参考配置文件【.gitignore】\n\tnpm与yarn参数说明：\n\t\t-g (global) 全局安装的时候请带上-g，不带则为局部安装\n\t\t-s (save)\n\t\t-d (dev)\n\t\t-D (=--save-dev) 将模块安装到项目目录下，并在package文件的dependencies节点写入依赖\n\t\tinit的时候带上-y为默认设置\n>>yarn和npm/pnpm/cnpm命令对比:\n    初始化             yarn init                                           npm init \n    安装依赖          yarn install 或者 yarn                      npm install pnpm install\n    新增依赖          yarn add element-ui                        npm install element-ui --save pnpm i element-ui\n    删除依赖          yarn remove element-ui                  npm uninstall element-ui --save …\n    更新依赖          yarn upgrade                                   npm update pnpm update\n    全局安装或删除   yarn global remove vue-cli          npm uninstall vue-cli -g …\n    同时下载多个       yarn add axios vue-axios            npm install --save axios vue-axios\n    更多命令请了解：\n    https://yarn.bootcss.com/\n    如果build遇到错误：Node Sass does not yet support your current environment: Windows 64-bit如何解决：\n    重新安装node-sass\n    yarn remove node-sass\n    yarn add node-sass\n')])])]),s("h2",{attrs:{id:"二、webpack"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、webpack"}},[n._v("#")]),n._v(" 二、webpack")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('#1.全局安装webpack\n#-y是默认配置\nnpm init -y\nyarn init -y\nnpm install webpack -g\nyarn add webpack -g\nyarn add webpack webpack-cli -g\n#安装指定版本：\nnpm install webpack@<version> -g        \n#例如：\nnpm install  webpack@4.41.2  -g\n#在全局下删除    \nnpm uninstall webpack -g\n#局部删除\nnpm uninstall webpack\n#查看安装是否成功\nwebpack -v\n#到项目文件下安装webpack\nnpm install webpack\n#3.安装全局的webpack-cli   \nnpm install -g webpack-cli\n#4.配置mode \n#默认有production和development两种模式可以设置\n#命令行设置  \nwebpack --mode development\n#5.新建入口  在项目文件目录下新建src文件夹，新建index.js文件入口\n#6.文件打包   命令行输入 \nwebpack --mode development 或 webpack --mode production\n#webpack将会默认打包，将./src/index.js文件打包成./dist/main.js文件（自动生成dist文件夹和main.js文件）\n#7.建立html文件，在项目目录下建立html文件，可以直接引用dist/main.js文件。\n#注意，我们的 script 引用的文件是 dist/main.js，而不是 index.js。\n#这正是前端开发领域的一个趋势：\n#开发的源文件（例子中的 index.js）与最终部署的文件（例子中的 dist/main.js）是区分开的，\n#之所以这样，是因为开发环境与用户的使用环境并不一致。\n#比如我们可以在开发环境使用 ES2017 甚至 ES2018 的特性，而用户的浏览器不见得支持,\n#这也是 webpack 等打包工具的一个意义，它们能够辅助我们构建出在目标用户浏览器上正常运行的代码。\n#8.其他参数配置\n#我们如果需要配置webpack指令的其他参数，只需要在webpack –mode production/development后加上其他参数即可，如：\nwebpack --mode development --watch --progress --display-modules --colors --display-reasons\n#实时刷新\n#9.监控文件\n#watch选项最为直观，但在默认情况下，watch选项是关闭状态。\n#启用watch选项    \nwebpack --mode development --watch\n#10.刷新浏览器\n#https://github.com/webpack/webpack-dev-server\n#https://webpack.js.org/configuration/dev-server/#devserver\n#webpack-dev-server,一个基于expressjs的开发服务器，提供实时刷新浏览器页面的功能。\n#安装webpack-dev-server\n#首先在项目下安装 webpack-dev-server: \nnpm install -g webpack-dev-server\n#然后在命令行下执行\nwebpack-dev-server --mode development --output-public-path dist\n#webpack-dev-server是一个轻量级的服务器，修改文件源码后，自动刷新页面将修改同步到页面上安装webpack-dev-server：\n#①全局安装：\nnpm install webpack-dev-server -g \n#②在项目中安装并将依赖写在package.json文件中:\nnpm install webpack-dev-server --save-dev\n#③使用命令\nwebpack-dev-server --mode development --output-public-path src\n#完成自动刷新，指定publicPath，这部分很容易没有实时刷新。\n#④默认的端口号是8080，如果需要8080端口被占用，就需要改端口，\nwebpack-dev-server --port 3000\n#(将端口号改为3000)，可以直接在webpack.config.js配置文件中配置devServer属性，开启热更新和port。\n#⑤启动服务，输入localhost:端口号，就显示发布的所有根目录，如果项目根目录中没有index.html文件，\n#就会在浏览器中列出项目根目录中的所有的文件夹。\n#⑥当使用\nwebpack-dev-server --mode development --output-public-path src\n#命令时，在每次修改文件，是将文件打包保存在内存中并没有写在磁盘里，\n#这种打包得到的文件和项目根目录中的index.html位于同一级。\n#使用webpack命令将打包后的文件保存在磁盘中例如在index.html文件中引入通过\n#webpack-dev-server --mode development  --output-public-path src\n#打包的build.js\n<script src="build.js"><\/script>　　\n#在index.html文件中引入通过webpack命令打包的build.js　\n<script src="./build/build.js"><\/script>\n#--inline 内联模式，在开发服务器的两种不同模式之间切换。\n#默认情况下, 应用程序将被启用内嵌模式。这意味着将在包中插入一个脚本来处理实时重装, 并且生成消息将出现在浏览器控制台中。\n#--hot 启用热模块更换功能\n#index.html入口文件是在根目录下，没有进行配置content-base，\n#因为配置了之后会只打包配置的目录文件，默认是根文件。\n#配置了output的publicPath\n#（很重要，删掉之后就不能自动刷新了，应该是webpack-dev-server将每次打包的文件根据output设置生成在publicPath目录下，\n#而文件本身依旧是手动打包的，无法查看到自动刷新打包的文件），\n#只配置了端口，没有配置hot:true和inline:true(最开始配置了，但是有报错，所以删掉莫名OK了）\n#⑦webpack自带的watch命令与webpack-dev-server的区别\n#--watch是文件修改后自动打包，webpack-dev-server是修改后发布到服务器上\n#⑧webpack-dev-server --mode development --content-base src --inline --hot//显示只针对src路径下的文件刷新,文件修改之后浏览器自动刷新，如果要打开的文件和打包的文件不在一个文件夹内，最好不要设定文件夹\n #11.打包css文件\n#在项目目录下安装处理css文件的loader\n#命令行输入：\nnpm install css-loader style-loader --save-dev\n#css-loader //处理css文件\n#style-loader //将css-loader处理后的文件作为样式标签<style>插入到html文件中\n#在处理css文件的时候要指定loader，如在index.js文件里输入\nrequire(\'style-loader!css-loader!./style.css\')\n#或者直接在命令行输入webpack --mode development --module-bind "css=style-loader!css-loader"\n#12--progress(查看进度)\n#13--display-modules(显示隐藏的模块)\n#14 --display-reasons(显示打包原因)\n #15.配置，webpack需要传入配置对象，因此进行新建配置文件webpack.config.js，\n #或者使用node.js内置的path模块进行配置，并在它前面加上 __dirname这个全局变量。\n #可以防止不同操作系统之间的文件路径问题，并且可以使相对路径按照预期工作。\n#①先写moudule.exports={};进行配置；\n#②入口文件配置，entry="入口文件路径，如./src/js/main.js";\n#③输出文件配置，output={path:__dirname+"输出文件路径，如/dist/js/bundle.js"};//要创建dist文件夹\n#__dirname为运行时的当前路径；\n#另一种方式，先定义const path = require("path");//引入nodejs的path模块\n#然后在输出文件路径path:path.resolve(__dirname,"./dist/js/bundle.js");\n#path.resolve()方法解析了当前路径，将相对路径改为绝对路径。\n#④重新指定配置文件名\n#webpack --config 文件名\n#如webpack --config webpack.dev.config.js\n#16.定义执行脚本，可以在package.json中设置\n#在script中设置，如设置"webpack":\n"webpack --mode development --config webpack.config.js --progress --display-modules --colors --display-reason",\n#//--colors(彩色显示)\n#直接执行上面的脚本npm run webpack\n#17.entry配置（chunk），\n#①字符串表示，单输入，所有依赖都要在入口文件中指定，如entry:"./src/js/main.js",\n#②数组表示，多输入，两个需要打包到一起的文件可以在配置文件的entry中用数组表示，\n#如entry:["./app/entry1", "./app/entry2"],//这两个文件将会打包到一起\n#③对象表示（哈希），多页面入口，entry:{page1:"./page1",page2:["./src/a.js","./src/b.js"]},\n#这三种方式都会把文件打包到输出文件中。\n#18.output配置，\n#①单个入口起点，就设置一个出口，如output:{filename:\'bundle.js\',path:\'/dist/js\'}\n#②多个入口起点，可以设置name或者hash，如output:{filename:\'[name].js\',path:__dirname+\'/dist/js\'}\n#或output:{filename:\'[name]-[hash].js\',path:__dirname+\'/dist/js\'}\n#或output:{filename:\'[name]-[chunkhash].js\',path:__dirname+\'/dist/js\'}\n#hash值可以认为是版本号或者MD5值保证每个文件的唯一性，每一次修改之后生成文件的hash值不一样，文件名不一样。\n#③publicPath可以理解为占位符。当需要上线的时候可以将服务器地址设置到这个参数中，\n#output:{path:\'xxx\',filename:\'xxx\',publicPath:\'http://cdn.com/\'}\n#插件（plugin）\n#插件是 webpack 的支柱功能。webpack 自身也是构建在 webpack 配置中用到的相同的插件系统之上。插件目的在于解决 loader 无法实现的其他事。\n#19.插件html-webpack-plugin\n#要引用之前先安装,在项目文件目录下安装 npm install html-webpack-plugin --save-dev\n#安装好之后，在webpack.config.js配置文件中对插件的引用\n#var htmlWebpackPlugin = require(\'html-webpack-plugin\');//commonJS写法\n#在module.exports中添加plugin部分进行插件初始化，\n#插件列表，当多个bundle需要共享一些相同的插件时，CommonChunkPlugin可以将这些依赖项提取到一个共享包中，以免重复。\nplugins:[\n    new webpack.optimize.CommonsChunkPlugin({\n        .....\n    }),\n    new htmlChunkPlugin({\n        template:\'index.html\',//自定义模板\n        filename:\'index-[hash].html\',//生成文件名\n        inject:\'head\',//指定链接注入在<head>标签中还是<body>标签中，为false值时表示不自动注入文件中，需要手动设置\n        title:\'webpack demo\',//传递参数，可以在index.html模板中引用\n        minify:{//压缩html文件，具体参数设置可以查看官方文档\n            \n        }\n    })\n]\n#index.html引用配置文件中的参数，JS语法模式，要使用JS语句可以使用<%%>将每行代码包裹起来。\n#赋值可以使用<%=xxx %>，如<%=htmlWebpackPlugin.options.title%>就可以取到配置文件中定义的title的值。\n#在配置文件中可以任意的配置参数向html文件进行传参。\n#自定义引用的js文件可以直接写到html文件中\n#如在html文件中相对应的位置写，<script src="<%=htmlWebpackPlugin.files.chunks.main.entry %>"><\/script>\n#<script src="<%=htmlWebpackPlugin.chunks.a.entry%>"><\/script>\n#chunk是文件入口\n#以上是单文件引用的示例，多文件引用则需要调用多次的html-webpack-plugin插件，设置方式相同\n#多页面使用同一个页面模板，可以定义htmlWebpackPlugin插件中的chunks参数，进行设置不同的页面引用不同的chunks，\n#如设置chunks:[\'main\',\'a\']\n#excludeChunks:[\'a\'],//指出排除的chunk\n#直接将公共初始化脚本嵌入到html页面中，inline方式，在html模板中加上脚本源码引用代码，\n#如\n<script type="text/javascript">\n<%=compilation.assets[htmlWebpackPlugin.files.chunks.main.entry.substr(htmlWebpackPlugin.files.publicPath.length)].source()%>\n<\/script>\n//.substr()的作用是将删除publicPath部分的绝对路径获取文件的相对路径。\n#按照文件顺序引用js文件可以手动设置for循环出htmlWebpackPlugin.files.chunks的entry值插入文件中。\n#20.loader\n#loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。\n# \n#本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。\nloader能够import导入任何类型的模块。\n在webpack的配置中loader有两个目标：\n①.test属性，用于表示出应该被对应的loader进行转换的某个或某些文件。\n②.use属性，表示进行转换时，应该使用那个loader。\n使用方式：\n①配置，在webpack.config.js中指定\n②内联，在每个import语句中显示指定loader\n③CLI，在shell命令中指定\n \n在webpack.config.js中配置loader\n在module.exports中添加属性module\n如安装babel插件（js编译器），使用此插件转换ES6代码，如何安装根据官网进行安装：\nmodule:{\n    rules:[\n       { test:/\\.js$/,\n        exclude:/node_modules/,\n        loader:"babel-loader"\n        }\n    ]\n}\n设置preset，指定preset（预配置）设置如何处理js文件\n①在rules中设置query:{presets:[\'latest\']}\n②在根目录下创建一个.babelrc文件,其中内容为：\n{\n    "presets":["env"]\n}\n③在package.json中，增加babel属性：\n"babel":{\n"presets":["latset"]\n}\n \n21.优化\n可以在配置文件中，设置打包范围，如exclude设置不处理哪些模块，include处理哪些文件下的内容。\n具体可以看官方文档进行配置。\n\n')])])]),s("h2",{attrs:{id:"三、webpack4-x-demo"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、webpack4-x-demo"}},[n._v("#")]),n._v(" 三、webpack4.x_demo")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('# VicUI >>>>> webpack4.X_demo\n\n####################################################################################################################\n\nyarn init -y\nyarn add webpack -g\nyarn add webpack -D\nyarn add webpack webpack-cli -g\nyarn add webpack webpack-cli -D\n#查看版本\nwebpack -v\n#如果提示不是内部命令，重新打开项目即可，或者用-D安装一遍再重新打开项目\n\n####################################################################################################################\n\n#新建新建两个文件夹，分别为src文件夹和dist文件夹，接下来再创建三个文件:\n#index.html --放在dist文件夹中；\n#hello.js --放在src文件夹中；\n#index.js --放在src文件夹中；\n#index.html中写下html代码\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Webpack Project</title>\n</head>\n<body>\n<div id=\'root\'></div>\n<script src="bundle.js"><\/script>   \x3c!--这是打包之后的js文件，不指定文件名的时候默认为main.js--\x3e\n</body>\n</html>\n\n#hello.js中导出一个模块：\nmodule.exports = function() {\n    let hello = document.createElement(\'div\');\n    hello.innerHTML = "Long time no see!";\n    return hello;\n  };\n\n#index.js中引入这个模块hello.js\nconst hello = require(\'./hello.js\');\ndocument.querySelector("#root").appendChild(hello());\n\n#相当于我们把hello.js模块合并到了index.js模块\n#之后我们打包时就只需把index.js模块打包成bundle.js\n#然后供index.html引用即可，这就是最简单的webpack打包原理。\n#webpack 打包，然后打开index.html即可看到信息。\n// webpack全局安装的情况下\nwebpack src/index.js --output dist/bundle.js  \n// --output可简写为-o\n#注：此处指定了打包生成的文件名为bundle.js如果不设置直接用webpack命令打包的话会默认为main.js\n\n####################################################################################################################\n\n#通过配置文件来使用webpack\n#当前项目的根目录下新建一个配置文件webpack.config.js\n#我们写下如下简单配置代码，目前只涉及入口配置（相当于我们的index.js，从它开始打包）和出口配置（相当于我们打包生成的bundle.js）\nmodule.exports = {\n    entry: __dirname + "/src/index.js", // 入口文件\n    output: {\n        path: __dirname + "/dist", //打包后的文件存放的地方\n        filename: "bundle.js" //打包后输出文件的文件名\n    }\n}\n#注：__dirname是node.js中的一个全局变量，它指向当前执行脚本所在的目录\n#平时我们看到的脚手架配置也比较喜欢采用node.js的path模块来处理绝对路径，所以我们也可以采用如下的写法，和上述的效果是一样的：\nconst path = require(\'path\');\nmodule.exports = {\n    entry: path.join(__dirname, "/src/index.js"), // 入口文件\n    output: {\n        path: path.join( __dirname, "/dist"), //打包后的文件存放的地方\n        filename: "bundle.js" //打包后输出文件的文件名\n    }\n}\n#注：path.join的功能是拼接路径片段\n#有了这个配置文件，我们只需在终端中运行webpack命令就可进行打包，这条命令会自动引用webpack.config.js文件中的配置选项\n\n####################################################################################################################\n\n#更智能的打包方式\n#现在只在终端中使用webpack命令来进行打包，要是以后在打包的同时还有更多的操作呢，那不是还得写上更多的命令？\n#所以我们得想办法把这些命令都集成起来，这时候之前的package.json文件就派上用场了。\n#现在的package.json文件大概就是如下这样\n{\n  "name": "webpack4.x_demo",\n  "version": "1.0.0",\n  "main": "index.js",\n  "license": "MIT",\n  "dependencies": {\n    "webpack": "^4.41.2",\n    "webpack-cli": "^3.3.10"\n  }\n}\n#修改如下：\n{\n  "name": "webpack4.x_demo",\n  "version": "1.0.0",\n  "main": "index.js",\n  "scripts": {\n      "start": "webpack", //改成这样，注意使用时把注释删掉\n    },\n  "license": "MIT",\n  "dependencies": {\n    "webpack": "^4.41.2",\n    "webpack-cli": "^3.3.10"\n  }\n}\n#注：package.json中的script会按你设置的命令名称来执行对应的命令。\n#这样我们就可以在终端中直接执行yarn start命令来进行打包\n#start命令比较特殊，可以直接yarn加上start就可以执行\n#如果我们想起其他的名称，如build时，就需要使用yarn run加上build，即yarn run build命令。\n#现在我们执行yarn start命令：打包成功。\n\n####################################################################################################################\n\n#构建本地服务器\n#现在我们是通过打开本地文件来查看页面的，看起来总感觉比较low\n#看别人用vue，react框架时都是运行在本地服务器上的，那我们能不能也那样呢？那必须的！\n#webpack-dev-server配置本地服务器\n#Webpack提供了一个可选的本地开发服务器，这个本地服务器基于node.js构建，它是一个单独的组件\n#在webpack中进行配置之前需要单独安装它作为项目依赖\nyarn add webpack-dev-server -D\n#devServer作为webpack配置选项中的一项，以下是它的一些配置选项:\ncontentBase ：设置服务器所读取文件的目录，当前我们设置为"./dist"\nport ：设置端口号，如果省略，默认为8080\ninline ：设置为true，当源文件改变时会自动刷新页面\nhistoryApiFallback ：设置为true，所有的跳转将指向index.html\n#现在我们把这些配置加到webpack.config.js文件上，如下：\nconst path = require(\'path\');\nmodule.exports = {\n    entry: path.join(__dirname, "/src/index.js"), // 入口文件\n    output: {\n        path: path.join( __dirname, "/dist"), //打包后的文件存放的地方\n        filename: "bundle.js" //打包后输出文件的文件名\n    },\n    devServer: {\n        contentBase: "./dist", // 本地服务器所加载文件的目录\n        port: "8088",   // 设置端口号为8088\n        inline: true, // 文件修改后实时刷新\n        historyApiFallback: true, //不跳转\n    }\n}\n#我们继续在package.json文件中添加启动命令：\n{\n  "name": "webpack4.x_demo",\n  "version": "1.0.0",\n  "main": "index.js",\n  "scripts": {\n    "build": "webpack",\n    "dev": "webpack-dev-server --open"\n  },\n  "license": "MIT",\n  "dependencies": {\n    "webpack": "^4.41.2",\n    "webpack-cli": "^3.3.10"\n  }\n}\n#我们把start命令名称改为了build，这样比较语义化，平时的脚手架也多数采用这个名称\n#我们用dev（development的缩写，意指开发环境）来启动本地服务器\n#webpack-dev-server就是启动服务器的命令，--open是用于启动完服务器后自动打开浏览器\n#这时候我们自定义命令方式的便捷性就体现出来了，可以多个命令集成在一起运行\n#即我们定义了一个dev命令名称就可以同时运行了webpack-dev-server和--open两个命令。\n#现在在终端输入yarn run dev运行服务器：\n#这样我们即可在\nhttp://localhost:8088/\n#中查看页面(退出服务器，可使用ctrl+c后，再按y确认，即可退出服务器运行)\n  \n####################################################################################################################\n\n#Source Maps调试配置\n#作为开发，代码调试当然少不了，那么问题来了，经过打包后的文件，你是不容易找到出错的地方的，Source Map就是用来解决这个问题的。\n#通过如下配置，我们会在打包时生成对应于打包文件的.map文件，使得编译后的代码可读性更高，更易于调试\n#webpack.config.js\nconst path = require(\'path\');\nmodule.exports = {\n    entry: path.join(__dirname, "/src/index.js"), // 入口文件\n    output: {\n        path: path.join( __dirname, "/dist"), //打包后的文件存放的地方\n        filename: "bundle.js" //打包后输出文件的文件名\n    },\n    devServer: {\n        contentBase: "./dist", // 本地服务器所加载文件的目录\n        port: "8088",  // 设置端口号为8088\n        inline: true, // 文件修改后实时刷新\n        historyApiFallback: true, //不跳转\n    },\n    devtool: \'source-map\'  // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度\n}\n#配置好后，我们再次运行yarn run build进行打包\n#这时我们会发现在dist文件夹中多出了一个bundle.js.map文件：\n#如果我们的代码有bug，在浏览器的调试工具中会提示错误出现的位置，这就是devtool: \'source-map\'配置项的作用。\n\n####################################################################################################################\n\n#Loaders\n#loaders是webpack最强大的功能之一\n#通过不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理\n#例如把scss转为css，将ES66、ES7等语法转化为当前浏览器能识别的语法，将JSX转化为js等多项功能。\n#Loaders需要单独安装并且需要在webpack.config.js中的modules配置项下进行配置，Loaders的配置包括以下几方面：\ntest：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须）\nloader：loader的名称（必须）\ninclude/exclude：手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；\noptions：为loaders提供额外的设置选项（可选）\n#配置css-loader\n#如果我们要加载一个css文件，需要安装配置style-loader和css-loader:\nyarn add style-loader css-loader -D\n#webpack.config.js\nconst path = require(\'path\');\nmodule.exports = {\n    entry: path.join(__dirname, "/src/index.js"), // 入口文件\n    output: {\n        path: path.join( __dirname, "/dist"), //打包后的文件存放的地方\n        filename: "bundle.js" //打包后输出文件的文件名\n    },\n    devServer: {\n        contentBase: "./dist", // 本地服务器所加载文件的目录\n        port: "8088",  // 设置端口号为8088\n        inline: true, // 文件修改后实时刷新\n        historyApiFallback: true, //不跳转\n    },\n    devtool: \'source-map\',  // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,   // 正则匹配以.css结尾的文件\n                use: [\'style-loader\', \'css-loader\']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的\n            }\n        ]\n    }\n}\n#我们在src文件夹下新建css文件夹，该文件夹内新建style.css文件：\n/* style.css */\nbody {\n    background: gray;\n}\n#在index.js中引用它：\nimport \'./css/style.css\';  //导入css\nconst hello = require(\'./hello.js\');\ndocument.querySelector("#root").appendChild(hello());\n#这时我们运行yarn run dev，会发现页面背景变成了灰色。\n#如果是要编译sass文件呢？\n\n####################################################################################################################\n\n #配置sass\n #因为sass-loader依赖于node-sass，所以还要安装node-sass\nyarn add sass-loader node-sass -D\n#增加sass的rules:\n#webpack.config.js\nconst path = require(\'path\');\nmodule.exports = {\n    entry: path.join(__dirname, "/src/index.js"), // 入口文件\n    output: {\n        path: path.join( __dirname, "/dist"), //打包后的文件存放的地方\n        filename: "bundle.js" //打包后输出文件的文件名\n    },\n    devServer: {\n        contentBase: "./dist", // 本地服务器所加载文件的目录\n        port: "8088",  // 设置端口号为8088\n        inline: true, // 文件修改后实时刷新\n        historyApiFallback: true, //不跳转\n    },\n    devtool: \'source-map\',  // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,   // 正则匹配以.css结尾的文件\n                use: [\'style-loader\', \'css-loader\']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的\n            },\n            {\n                test: /\\.(scss|sass)$/,   // 正则匹配以.scss和.sass结尾的文件\n                use: [\'style-loader\', \'css-loader\', \'sass-loader\']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的\n            }\n        ]\n    }\n}\n\n#在css文件夹中新建blue.scss文件：\n/* blue.scss */\n$blue: blue;\nbody{\n    color: $blue;\n} \n#在index.js中引入blue.scss：\n#index.js \nimport \'./css/style.css\';   // 导入css\nimport \'./css/blue.scss\';   // 导入scss\n\nconst hello = require(\'./hello.js\');\ndocument.querySelector("#root").appendChild(hello());\n#这时yarn run dev重新启动服务器，应该会出现如下结果：灰色背景，蓝色字体\n#还有诸如图片loader、字体loader等就不一一列出来了，感兴趣的可前往webpack官网查看，都是一样的套路。\n\n####################################################################################################################\n\n#Babel\n#Babel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的：\n#让你能使用最新的JavaScript代码（ES6，ES7...），而不用管新标准是否被当前使用的浏览器完全支持；\n#让你能使用基于JavaScript进行了拓展的语言，比如React的JSX；\n\n#Babel的安装与配置\n#Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中\n#webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展,你都需要安装单独的包\n#（用得最多的是解析ES6的babel-preset-env包和解析JSX的babel-preset-react包）。\n#babel-preset-env的env表示是对当前环境的预处理，而不是像以前使用babel-preset-es2015只能针对某个环境\nyarn add babel-core babel-loader babel-preset-env babel-preset-react -D\n#webpack.config.js\nconst path = require(\'path\');\nmodule.exports = {\n    entry: path.join(__dirname, "/src/index.js"), // 入口文件\n    output: {\n        path: path.join( __dirname, "/dist"), //打包后的文件存放的地方\n        filename: "bundle.js" //打包后输出文件的文件名\n    },\n    devServer: {\n        contentBase: "./dist", // 本地服务器所加载文件的目录\n        port: "8088",  // 设置端口号为8088\n        inline: true, // 文件修改后实时刷新\n        historyApiFallback: true, //不跳转\n    },\n    devtool: \'source-map\',  // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,   // 正则匹配以.css结尾的文件\n                use: [\'style-loader\', \'css-loader\']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的\n            },\n            {\n                test: /\\.(scss|sass)$/,   // 正则匹配以.scss和.sass结尾的文件\n                use: [\'style-loader\', \'css-loader\', \'sass-loader\']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的\n            },\n            {                             // jsx配置\n                test: /(\\.jsx|\\.js)$/,   \n                use: {                    // 注意use选择如果有多项配置，可写成这种对象形式\n                    loader: "babel-loader",\n                    options: {\n                        presets: [\n                            "env", "react"\n                        ]\n                    }\n                },\n                exclude: /node_modules/\n            }\n        ]\n    }\n}\n\n#现在我们已经可以支持ES6及JSX的语法了，我们用react来试试，但使用react还得先安装两个模块react和react-dom。\nyarn add react react-dom -D\n#此处会有警告：babel-loader@8.0.6" has unmet peer dependency "@babel/core@^7.0.0".后续会讲\n#把hello.js文件修改一下：\n#hello.js\nimport React, {Component} from \'react\'; // 这两个模块必须引入\n\nlet name = \'Alan\';\n\nexport default class Hello extends Component{\n    render() {\n        return (\n            <div>\n                {name}\n            </div>\n        );\n    }\n}\n\n#修改index.js文件：\n#index.js \nimport \'./css/style.css\';  // 导入css\nimport \'./css/blue.scss\';  // 导入scss\n\nimport React from \'react\';\nimport {render} from \'react-dom\';\nimport Hello from \'./hello\'; // 可省略.js后缀名\n\nrender(<Hello />, document.getElementById(\'root\'));\n\n#此时运行yarn run dev后你可能会发现报错\n#这是因为官方默认babel-loader | babel对应的版本需要一致: 即babel-loader需要搭配最新版本babel\n#（其实安装的时候就有警告）\n#两种解决方案:\n#回退低版本\nyarn add babel-loader@7 babel-core babel-preset-env -D\n#更新到最高版本:\nyarn add babel-loader @babel/core @babel/preset-env webpack -D\n#这里采取的是第一个方案，回退后，再此运行yarn run dev，成功：\n\n####################################################################################################################\n\n#优化babel配置\n#虽然babel完全可以在webpack.config.js中进行配置，但现在不是都提倡模块化嘛，也许之后babel膨胀了，增加了更多的配置项呢？\n#那我们不如把它提取出来，把它放到根目录下的.babelrc文件下（webpack会自动调用.babelrc里的babel配置选项）。\n#我们在项目根目录下新建.babelrc文件：\n#webpack.config.js\nconst path = require(\'path\');\nmodule.exports = {\n    entry: path.join(__dirname, "/src/index.js"), // 入口文件\n    output: {\n        path: path.join( __dirname, "/dist"), //打包后的文件存放的地方\n        filename: "bundle.js" //打包后输出文件的文件名\n    },\n    devServer: {\n        contentBase: "./dist", // 本地服务器所加载文件的目录\n        port: "8088",  // 设置端口号为8088\n        inline: true, // 文件修改后实时刷新\n        historyApiFallback: true, //不跳转\n    },\n    devtool: \'source-map\',  // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,   // 正则匹配以.css结尾的文件\n                use: [\'style-loader\', \'css-loader\']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的\n            },\n            {\n                test: /\\.(scss|sass)$/,   // 正则匹配以.scss和.sass结尾的文件\n                use: [\'style-loader\', \'css-loader\', \'sass-loader\']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的\n            },\n            {                             // jsx配置\n                test: /(\\.jsx|\\.js)$/,   \n                use: {                    // 注意use选择如果有多项配置，可写成这种对象形式\n                    loader: "babel-loader"\n                },\n                exclude: /node_modules/   // 排除匹配node_modules模块\n            }\n        ]\n    }\n}\n\n# .babelrc 使用时把注释删掉，该文件不能添加注释\n{\n    "presets": ["env", "react"]\n}\n#此时不出问题的话应该一切运行正常\n\n####################################################################################################################\n\n#插件（Plugins）\n#插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。\n#Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西\n#loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个\n#插件并不直接操作单个文件，它直接对整个构建过程起作用。\n#使用某个插件，需要通过npm进行安装，然后在webpack.config.js配置文件的plugins(是一个数组)\n#配置项中添加该插件的实例，下面我们先来使用一个简单的版权声明插件。\n#webpack.config.js 添加以下配置\nconst webpack = require(\'webpack\');  // 这个插件不需要安装，是基于webpack的，需要引入webpack模块\nplugins: [\n    new webpack.BannerPlugin(\'版权所有，翻版必究\')  // new一个插件的实例\n]\n\n#运行yarn run build打包后我们看到bundle.js文件显示如下：\n/*! 版权所有，翻版必究 */!\n\n##############################################################################################################\n\n#自动生成html文件(HtmlWebpackPlugin)\n#到目前为止我们都是使用一开始建好的index.html文件，而且也是手动引入bundle.js\n#要是以后我们引入不止一个js文件，而且更改js文件名的话，也得手动更改index.html中的js文件名\n#所以能不能自动生成index.html且自动引用打包后的js呢？HtmlWebpackPlugin插件就是用来解决这个问题的：\n#首先安装该插件\nyarn add html-webpack-plugin -D\n#然后我们对项目结构进行一些更改：\n#把dist整个文件夹删除；\n#在src文件夹下新建一个index.template.html(名称自定义)文件模板\n#（当然这个是可选的，因为就算不设置模板，HtmlWebpackPlugin插件也会生成默认html文件，这里我们设置模块会让我们的开发更加灵活），如下：\n\x3c!-- index.template.html --\x3e\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8">\n    <title>Here is Template</title>\n  </head>\n  <body>\n    <div id=\'root\'>\n    </div>\n  </body>\n</html>\n\n#webpack.config.js中我们引入了HtmlWebpackPlugin插件，并配置了引用了我们设置的模板，如下：\n#webpack.config.js\nconst path = require(\'path\');  // 路径处理模块\nconst webpack = require(\'webpack\');  // 这个插件不需要安装，是基于webpack的，需要引入webpack模块\nconst HtmlWebpackPlugin = require(\'html-webpack-plugin\'); // 引入HtmlWebpackPlugin插件\n\nmodule.exports = {\n    entry: path.join(__dirname, "/src/index.js"), // 入口文件\n    output: {\n        path: path.join( __dirname, "/dist"), //打包后的文件存放的地方\n        filename: "bundle.js" //打包后输出文件的文件名\n    },\n    devServer: {\n        contentBase: "./dist", // 本地服务器所加载文件的目录\n        port: "8088",  // 设置端口号为8088\n        inline: true, // 文件修改后实时刷新\n        historyApiFallback: true, //不跳转\n    },\n    devtool: \'source-map\',  // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,   // 正则匹配以.css结尾的文件\n                use: [\'style-loader\', \'css-loader\']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的\n            },\n            {\n                test: /\\.(scss|sass)$/,   // 正则匹配以.scss和.sass结尾的文件\n                use: [\'style-loader\', \'css-loader\', \'sass-loader\']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的\n            },\n            {                             // jsx配置\n                test: /(\\.jsx|\\.js)$/,   \n                use: {                    // 注意use选择如果有多项配置，可写成这种对象形式\n                    loader: "babel-loader"\n                },\n                exclude: /node_modules/   // 排除匹配node_modules模块\n            }\n        ]\n    },\n    plugins: [\n        new webpack.BannerPlugin(\'版权所有，翻版必究\'),  // new一个插件的实例 \n        new HtmlWebpackPlugin({\n            template: path.join(__dirname, "/src/index.template.html")// new一个这个插件的实例，并传入相关的参数\n        })\n    ]\n}\n#然后我们使用yarn run build进行打包，你会发现，dist文件夹和html文件都会自动生成\n\n#为什么会自动生成dist文件夹呢？因为我们在output出口配置项中定义了出口文件所在的位置为dist文件夹,且出口文件名为bundle.js\n#所以HtmlWebpackPlugin会自动帮你在index.html中引用名为bundle.js文件\n#如果你在webpack.config.js文件中更改了出口文件名，index.html中也会自动更改该文件名，这样以后修改起来是不是方便多了？\n\n########################################################################################################\n\n#清理/dist文件夹(CleanWebpackPlugin)\n#你可能已经注意到，在我们删掉/dist文件夹之前，由于前面的代码示例遗留，导致我们的/dist文件夹比较杂乱\n#webpack会生成文件，然后将这些文件放置在/dist文件夹中，但是webpack无法追踪到哪些文件是实际在项目中用到的。\n#通常，在每次构建前清理/dist文件夹，是比较推荐的做法，因此只会生成用到的文件，这时候就用到CleanWebpackPlugin插件了。\nyarn add clean-webpack-plugin -D\n#webpack.config.js\n老版本写法\n...\nconst CleanWebpackPlugin = require(\'clean-webpack-plugin\'); // 引入CleanWebpackPlugin插件\n\nmodule.exports = {\n    ...\n    plugins: [\n        new webpack.BannerPlugin(\'版权所有，翻版必究\'),  // new一个插件的实例 \n        new HtmlWebpackPlugin({\n            template: path.join(__dirname, "/src/index.template.html")// new一个这个插件的实例，并传入相关的参数\n        }),\n        new CleanWebpackPlugin([\'dist\']),  // 所要清理的文件夹名称\n    ]\n}\n\n新版本写法\n...\nconst { CleanWebpackPlugin } = require("clean-webpack-plugin");// 引入CleanWebpackPlugin插件\n\nmodule.exports = {\n    ...\n    plugins: [\n        new webpack.BannerPlugin(\'版权所有，翻版必究\'),  // new一个插件的实例 \n        new HtmlWebpackPlugin({\n            template: path.join(__dirname, "/src/index.template.html")// new一个这个插件的实例，并传入相关的参数\n        }),\n        new CleanWebpackPlugin()\n    ]\n}\n\n#插件的使用方法都是一样的，首先引入，然后new一个实例，实例可传入参数。\n#现在我们运行yarn run build后就会发现，webpack会先将/dist文件夹删除，然后再生产新的/dist文件夹。\n#出现警告：Entrypoint undefined = index.html\n##webpack.config.js 中的 module.exports 新增 stats: { children: false },即可解决该警告\n\n########################################################################################################\n\n#热更新(HotModuleReplacementPlugin)\n\n#HotModuleReplacementPlugin（HMR）是一个很实用的插件，可以在我们修改代码后自动刷新预览效果。\ndevServer配置项中添加hot: true参数。\n#因为HotModuleReplacementPlugin是webpack模块自带的，所以引入webpack后，在plugins配置项中直接使用即可。\n# webpack.config.js\n...\nconst webpack = require(\'webpack\');  // 这个插件不需要安装，是基于webpack的，需要引入webpack模块\n\nmodule.exports = {\n    ...\n    devServer: {\n        contentBase: "./dist", // 本地服务器所加载文件的目录\n        port: "8088",  // 设置端口号为8088\n        inline: true, // 文件修改后实时刷新\n        historyApiFallback: true, //不跳转\n        hot: true // 热更新\n    },\n    ...\n    plugins: [\n        new webpack.BannerPlugin(\'版权所有，翻版必究\'),  // new一个插件的实例 \n        new HtmlWebpackPlugin({\n            template: path.join(__dirname, "/src/index.template.html")// new一个这个插件的实例，并传入相关的参数\n        }),\n        new CleanWebpackPlugin([\'dist\']),  // 传入所要清理的文件夹名称\n        new webpack.HotModuleReplacementPlugin() // 热更新插件 \n    ]\n}\n\n#此时我们重新启动项目yarn run dev后，修改hello.js的内容，会发现浏览器预览效果会自动刷新\n#（也许反应会比较慢，因为我们使用了source-map和其他配置的影响，后面代码分离的时候我们再处理）。\n\n########################################################################################################\n\n#项目优化及拓展\n#代码分离\n#在当前的开发环境都是提倡模块化，webpack自然不例外\n#我们前面的webpack.config.js配置文件，其实也没配置多少东西就这么多了，要是以后增加了更多配置，岂不是看得眼花缭乱\n#所以最好的方法就是把它拆分，方便管理：\n#1. 我们在根目录下新建三个文件，分别为webpack.common.js、webpack.dev.js、webpack.prod.js\n#分别代表公共配置文件、开发环境配置文件、生产环境（指项目上线时的环境）配置文件。\n#2. 安装一个合并模块插件：\nyarn add webpack-merge -D\n#3. 将webpack.config.js的代码拆分到上述新建的三个文件中，然后把webpack.config.js文件删除，具体如下：\n#webpack.common.js\nconst path = require(\'path\');  // 路径处理模块\nconst webpack = require(\'webpack\');  // 这个插件不需要安装，是基于webpack的，需要引入webpack模块\nconst HtmlWebpackPlugin = require(\'html-webpack-plugin\'); // 引入HtmlWebpackPlugin插件\n\nmodule.exports = {\n    stats: { children: false },\n    entry: path.join(__dirname, "/src/index.js"), // 入口文件\n    output: {\n        path: path.join( __dirname, "/dist"), //打包后的文件存放的地方\n        filename: "bundle.js" //打包后输出文件的文件名\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,   // 正则匹配以.css结尾的文件\n                use: [\'style-loader\', \'css-loader\']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的\n            },\n            {\n                test: /\\.(scss|sass)$/,   // 正则匹配以.scss和.sass结尾的文件\n                use: [\'style-loader\', \'css-loader\', \'sass-loader\']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的\n            },\n            {                             // jsx配置\n                test: /(\\.jsx|\\.js)$/,\n                use: {                    // 注意use选择如果有多项配置，可写成这种对象形式\n                    loader: "babel-loader"\n                },\n                exclude: /node_modules/   // 排除匹配node_modules模块\n            }\n        ]\n    },\n    plugins: [\n        new webpack.BannerPlugin(\'版权所有，翻版必究\'),  // new一个插件的实例\n        new HtmlWebpackPlugin({\n            template: path.join(__dirname, "/src/index.template.html")// new一个这个插件的实例，并传入相关的参数\n        }),\n        new webpack.HotModuleReplacementPlugin() // 热更新插件\n    ]\n}\n\n#webpack.dev.js\nconst merge = require(\'webpack-merge\');  // 引入webpack-merge功能模块\nconst common = require(\'./webpack.common.js\'); // 引入webpack.common.js\n\nmodule.exports = merge(common, {   // 将webpack.common.js合并到当前文件\n    devServer: {\n        contentBase: "./dist",   // 本地服务器所加载文件的目录\n        port: "8088",  // 设置端口号为8088\n        inline: true,  // 文件修改后实时刷新\n        historyApiFallback: true, //不跳转\n        hot: true     //热加载\n    }\n})\n\n#webpack.prod.js\nconst merge = require(\'webpack-merge\');\nconst common = require(\'./webpack.common.js\');\nconst { CleanWebpackPlugin } = require("clean-webpack-plugin");// 引入CleanWebpackPlugin插件\n\nmodule.exports = merge(common, { // 将webpack.common.js合并到当前文件\n    devtool: \'source-map\',  // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度\n    plugins: [\n        new CleanWebpackPlugin()  // 所要清理的dist文件夹\n    ]\n})\n\n# 设置package.json的scripts命令：\n{\n  "name": "webpack4.x_demo",\n  "version": "1.0.0",\n  "main": "index.js",\n  "scripts": {\n    "build": "webpack --config webpack.prod.js",\n    "dev": "webpack-dev-server --open --config webpack.dev.js"\n  },\n  "license": "MIT",\n  "dependencies": {\n    "webpack": "^4.41.2",\n    "webpack-cli": "^3.3.10"\n  },\n  "devDependencies": {\n    "babel-core": "^6.26.3",\n    "babel-loader": "7",\n    "babel-preset-env": "^1.7.0",\n    "babel-preset-react": "^6.24.1",\n    "clean-webpack-plugin": "^3.0.0",\n    "css-loader": "^3.2.0",\n    "html-webpack-plugin": "^3.2.0",\n    "node-sass": "^4.13.0",\n    "react": "^16.12.0",\n    "react-dom": "^16.12.0",\n    "sass-loader": "^8.0.0",\n    "style-loader": "^1.0.0",\n    "webpack-dev-server": "^3.9.0",\n    "webpack-merge": "^4.2.2"\n  }\n}\n\n#我们把build命令改为了webpack --config webpack.prod.js，意思是把打包配置指向webpack.prod.js配置文件\n#之前我们只需要使用一个webpack命令为什么就可以运行了？因为webpack命令是默认指向webpack.config.js这个文件名称的\n#现在我们把文件名称改了，所以就需要自定义指向新的文件，dev命令中的指令也同理。\n#然后我们运行yarn run build和yarn run dev，效果应该和我们分离代码前是一样的。\n\n#注：说到package.json文件，顺便就多提几句，因为也许有些朋友可能对我们安装模块时加的-D、-S或-g命令存在一些疑惑，因为不知道什么时候加什么尾缀。\n#其实这个package.json文件是用于我们安装依赖的，可以把它当成一份依赖安装说明表\n#就是如果我们把项目上传或者发给其他的开发同事，肯定不会把/node_modules文件夹也发送过去，因为这太大了，不现实也没必要。\n#开发同事只需要有这份package.json文件，然后yarn install就可以把我们所需要的依赖都安装下来\n#但前提是package.json文件上有记录，这就是安装模块时加上-D,-S命令的原因。\n#-D的全称是--save-dev指开发环境时需要用到的依赖，会记录在package.json文件中的devDependencies选项中\n#-S是--save是指生产环境也就是上线环境中需要用到的依赖，会记录在package.json文件中的dependencies选项中\n#-g的全称是--global指安装全局命令，就是我们在本电脑的任何项目中都能使用到的命令，比如安装cnpm这个淘宝镜像命令就会用到-g命令。\n#所以我们在安装模块时一定不要忘了加上对应的尾缀命令，让我们的模块有迹可循\n\n########################################################################################################\n\n#多入口多出口\n#到目前为止我们都是一个入口文件和一个出口文件，要是我不止一个入口文件呢？下面我们来试试：\n#在webpack.common.js中的entry入口有三种写法，分别为字符串、数组和对象\n#平时我们用得比较多的是对象，所以我们把它改为对象的写法\n#首先我们在src文件夹下新建two.js文件，名称任意。因为有多个入口，所以肯定得多个出口来进行一一对应了，所以entry和output配置如下：\n#webpack.common.js\n...\nmodule.exports = {\n    entry: {\n        index: path.join(__dirname, "/src/index.js"), //多个入口文件\n        two: path.join(__dirname, "/src/two.js")\n    }, \n    output: {\n        path: path.join( __dirname, "/dist"), //打包后的文件存放的地方\n        filename: "[name].js" //打包后输出文件的文件名\n    },\n    ...\n}\n#two.js\nfunction two() {\n    let element = document.createElement(\'div\');\n    element.innerHTML = \'我是第二个入口文件\';\n    return element;\n}\n\ndocument.getElementById(\'root\').appendChild(two());\n\n#然后我们运行yarn run build打包后发现/dist文件夹下会多出two.js文件\n#同时index.html也会自动将two.js引入，然后我们运行yarn run dev显示成功\n\n########################################################################################################\n\n#增加css前缀、分离css、消除冗余css、分离图片\n#增加css前缀\n#平时我们写css时，一些属性需要手动加上前缀，比如-webkit-border-radius: 10px;\n#在webpack中我们能不能让它自动加上呢？那是必须的，首先肯定得安装模块了：\nyarn add postcss-loader autoprefixer -D\n#安装好这两个模块后，在项目根目录下新建postcss.config.js文件:\n#postcss.config.js\nmodule.exports = {\n    plugins: [\n        require(\'autoprefixer\')  // 引用autoprefixer模块\n    ]\n}\n#在style.css中增加以下样式：\n/* style.css */\nbody {\n    background: #999;\n}\n\n#root div{\n    width: 200px;\n    margin-top: 50px;\n    transform: rotate(45deg); /* 这个属性会产生前缀 */\n}\n#修改webpack.common.js文件中的css-loader配置：\n...\nmodule.exports = {\n    ...\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,   // 正则匹配以.css结尾的文件\n                use: [            \n                    {loader: \'style-loader\'}, // 这里采用的是对象配置loader的写法\n                    {loader: \'css-loader\'},\n                    {loader: \'postcss-loader\'} // 使用postcss-loader\n                ]  \n            },\n            ...\n        ]\n    },\n    ...\n}\n\n#然后我们运行yarn run dev后css样式中会自动添加前缀webkit\n\n########################################################################################################\n\n#分离css\n#虽然webpack的理念是把css、js全都打包到一个文件里，但要是我们想把css分离出来该怎么做呢？\n#加上@next是为了安装最新的，否则会出错\nyarn add extract-text-webpack-plugin@next -D \n#安装完以上插件后在webpack.common.js文件中引入并使用该插件：\n// webpack.common.js\n...\nconst ExtractTextPlugin = require(\'extract-text-webpack-plugin\') //引入分离插件\n\nmodule.exports = {\n    ...\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,   // 正则匹配以.css结尾的文件\n                use: ExtractTextPlugin.extract({  // 这里我们需要调用分离插件内的extract方法\n                    fallback: \'style-loader\',  // 相当于回滚，经postcss-loader和css-loader处理过的css最终再经过style-loader处理\n                    use: [\'css-loader\', \'postcss-loader\']\n                })\n            },\n            ...\n        ]\n    },\n    plugins: [\n        ...\n        new ExtractTextPlugin(\'css/index.css\') // 将css分离到/dist文件夹下的css文件夹中的index.css\n    ]\n}\n#运行yarn run build后会发现/dist文件夹内多出了/css文件夹及index.css文件。\n\n########################################################################################################\n\n#消除冗余css\n#有时候我们css写得多了，可能会不自觉的写重复了一些样式，这就造成了多余的代码，上线前又忘了检查\n#对于这方面，我们应该尽量去优化它，webpack就有这个功能。\nyarn add purifycss-webpack purify-css glob -D\n#安装完上述三个模块后，因为正常来说是在生产环境中优化代码，所以我们应该是在webpack.prod.js文件中进行配置\n#引入clean-webpack-plugin及glob插件并使用它们：\n#webpack.prod.js\nconst merge = require(\'webpack-merge\');\nconst common = require(\'./webpack.common.js\');\nconst CleanWebpackPlugin = require(\'clean-webpack-plugin\'); // 引入CleanWebpackPlugin插件\n\nconst path = require(\'path\');\nconst PurifyCssWebpack = require(\'purifycss-webpack\'); // 引入PurifyCssWebpack插件\nconst glob = require(\'glob\');  // 引入glob模块,用于扫描全部html文件中所引用的css\n\nmodule.exports = merge(common, {   // 将webpack.common.js合并到当前文件\n    devtool: \'source-map\',  // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度\n    plugins: [\n        new CleanWebpackPlugin([\'dist\']),  // 所要清理的文件夹名称\n        new PurifyCssWebpack({\n            paths: glob.sync(path.join(__dirname, \'src/*.html\')) // 同步扫描所有html文件中所引用的css\n        })\n    ]\n})\n#我们在style.css文件中增加一些多余的代码试试：\n/* style.css */\nbody {\n    background: #999;\n}\n\n#root div{\n    width: 200px;\n    margin-top: 50px;\n    transform: rotate(45deg); /* 这个属性会产生前缀 */\n}\n\n.a{                 /* 冗余css */\n    color: black;     \n}\n\n.b{                 /* 冗余css */\n    width: 50px;\n    height: 50px;\n    background: yellow;\n}\n#然后我们运行yarn run build后发现打包后的index.css中是没有多余的.a和.b代码的：\n/*! 版权所有，翻版必究 */\n/* style.css */\nbody {\n    background: #999;\n}\n\n#root div{\n    width: 200px;\n    margin-top: 50px;\n    -webkit-transform: rotate(45deg);\n            transform: rotate(45deg); /* 这个属性会产生前缀 */\n}\n\n/*# sourceMappingURL=index.css.map*/\n\n########################################################################################################\n\n#处理图片\n#到目前为止我们还没讲到图片的问题，如果要使用图片，我们得安装两个loader：\n#虽然我们只需使用url-loader，但url-loader是依赖于file-loader的，所以也要安装\nyarn add url-loader file-loader -D\n#然后在webpack.common.js中配置url-loader：\n#webpack.common.js\n...\nmodule.exports = {\n    ...\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,   // 正则匹配以.css结尾的文件\n                use: ExtractTextPlugin.extract({\n                    fallback: \'style-loader\',\n                    use: [\'css-loader\', \'postcss-loader\']\n                })\n            },\n            {\n                test: /\\.(png|jpg|svg|gif)$/,  // 正则匹配图片格式名\n                use: [\n                    {\n                        loader: \'url-loader\'  // 使用url-loader\n                    }\n                ]\n            },\n            ...\n        ]\n    },\n    ...\n}\n\n#src 下新建images文件夹，添加图片coffee.png图片\n#我们修改一下style.css，把背景改为图片背景：\n/* style.css */\nbody {\n    background: url(../images/coffee.png) top right repeat-y;  /* 设为图片背景 */\n}\n\n#root div{\n    width: 200px;\n    margin-top: 50px;\n    transform: rotate(45deg); /* 这个属性会产生前缀 */\n}\n\n.a{\n    color: black;\n}\n\n.b{\n    width: 50px;\n    height: 50px;\n    background: yellow;\n}\n#运行yarn run dev后c查看显示\n#但是背景图片变成了base64，因为webpack会自动优化图片，减少发送请求，但是如果我想把它变成路径的该怎么做？\n#我们可以把webpack.common.js的loader配置更改一下，增加options选项：\n#webpack.common.js\n...\nmodule.exports = {\n    ...\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,   // 正则匹配以.css结尾的文件\n                use: ExtractTextPlugin.extract({\n                    fallback: \'style-loader\',\n                    use: [\'css-loader\', \'postcss-loader\']\n                })\n            },\n            {\n                test: /\\.(png|jpg|svg|gif)$/,\n                use: [\n                    {\n                        loader: \'url-loader\',\n                        options: {\n                            limit: 1000  // 限制只有小于1kb的图片才转为base64，例子图片为1.47kb,所以不会被转化\n                        }\n                    }\n                ]\n            },\n            ...\n        ]\n    },\n    ...\n}\n#然后我们运行yarn run build后，再运行yarn run dev，额，图片是没有转成base64了，但是图片怎么不显示了？\n#问题就出在路径上，我们之前图片的路径是在../images文件夹下，但是打包出来后没有这个路径了\n#图片直接和文件同级了，所以我们需要在webpack.common.js中给它设置一个文件夹：\n#webpack.common.js\n...\nmodule.exports = {\n    ...\n    module: {\n        rules: [\n            ...\n            {\n                test: /\\.(png|jpg|svg|gif)$/,\n                use: [\n                    {\n                        loader: \'url-loader\',\n                        options: {\n                            limit: 1000,  // 限制只有小于1kb的图片才转为base64，例子图片为1.47kb,所以不会被转化\n                            outputPath: \'images\'  // 设置打包后图片存放的文件夹名称\n                        }\n                    }\n                ]\n            },\n            ...\n        ]\n    },\n    ...\n}\n#继续yarn run build打包再yarn run dev运行，我的天！图片还是不显示！\n#调试工具上看图片路径有images文件夹了，但是我的../呢？\n#这又涉及到配置路径的问题上了，我们还需要在css-loader中给背景图片设置一个公共路径publicPath: \'../\'，如下：\n#webpack.common.js\n...\nmodule.exports = {\n    ...\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,   // 正则匹配以.css结尾的文件\n                use: ExtractTextPlugin.extract({\n                    fallback: \'style-loader\',\n                    use: [\'css-loader\', \'postcss-loader\'],\n                    publicPath: \'../\'  // 给背景图片设置一个公共路径\n                })\n            },\n            {\n                test: /\\.(png|jpg|svg|gif)$/,\n                use: [\n                    {\n                        loader: \'url-loader\',\n                        options: {\n                            limit: 1000,  // 限制只有小于1kb的图片才转为base64，例子图片为1.47kb,所以不会被转化\n                            outputPath: \'images\'  // 设置打包后图片存放的文件夹名称\n                        }\n                    }\n                ]\n            },\n            ...\n        ]\n    },\n    ...\n}\n#现在再yarn run build打包再yarn run dev启动，OK！没毛病！\n\n########################################################################################################\n\n#压缩代码\n#在webpack4.x版本中当你打包时会自动把js压缩了，而且yarn run dev运行服务器时，当你修改代码时，热更新很慢\n#这是因为你修改后webpack又自动为你打包，这就导致了在开发环境中效率很慢，所以我们需要把开发环境和生产环境区分开来\n#这时就体现出我们代码分离的便捷性了，webpack.dev.js代表开发环境的配置，webpack.prod.js代表生产环境的配置\n#这时我们只要在package.json文件中配置对应环境的命令即可：\n{\n  ...\n  "scripts": {\n    "build": "webpack --config webpack.prod.js --mode production",\n    "dev": "webpack-dev-server --open --config webpack.dev.js --mode development"\n  },\n  ...\n  }\n}\n#--mode production表示打包时是生产环境，会自己将js进行压缩\n#--mode development表示当前是开发环境，不需要进行压缩。\n#这同时也解决了之前一直遗留的警告问题：\n\n########################################################################################################\n\n#总结\n#到此基本把webapck常用的功能都走了一遍，更多功能请参考官方文档学习\n#完整代码请前往github：https://github.com/sp1203/VicUI/tree/master/webpack4.x_demo\n\n')])])]),s("h2",{attrs:{id:"四、webpack4-vue2-x-demo"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、webpack4-vue2-x-demo"}},[n._v("#")]),n._v(" 四、webpack4_vue2.x_demo")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('# VicUI >>>>> webpack4_vue2.x_demo\n#简单搭建webpack4+vue2.X\n#初始化（-y是代表默认设置）\nyarn init -y\n#添加依赖（-g是代表全局,全局已经安装过的，项目内安装不要带-g）【卸载用remove】\nyarn add webpack -g\nyarn add webpack webpack-cli -g\n#查看是否安装成功\nyarn -v\n#在根目录创建index.html\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>webpack4-vue-demo</title>\n</head>\n<body>\n    <div id="root"></div>\n</body>\n</html>\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n#创建src文件夹，并在src下创建index.js\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\nalert("hello!webpack4!")\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n#打包webpack，成功，会有warning，因为尚未设置模式\n#多了一个dist文件夹，webpack4在打包时默认入口文件为src目录下的index.js，输出地址为dist文件夹，文件为main.js\n#修改index.html代码，引入<script src="./dist/main.js"><\/script>\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>webpack4-vue-demo</title>\n</head>\n<body>\n    <div id="root"></div>\n    <script src="./dist/main.js"><\/script>\n</body>\n</html>\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n#在浏览器中打开，可以发现页面能调用index.js里的内容了\n####################################################################################################\n#添加vue\nyarn add vue\n#添加vue-loader\nyarn add vue-loader\n#在src下创建App.vue\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n<template>\n    <div>{{msg}}</div>\n</template>\n<script>\nexport default{\n    data(){\n        return{\n            msg: \'hello! webpack4-vue-demo!\'\n        }\n    }\n}\n<\/script>\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n#修改index.js\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\nimport Vue from \'vue\'\nimport App from \'./App.vue\'\n\nnew Vue({\n    el: "#root",\n    render:h=>h(App)\n})\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n#打包会报错\n#因为vue-loader需要以插件的形式引入,即使安装了，但是我们需要在webpack.config.js中配置\n#在根目录下创建webpack.config.js\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\nconst path = require(\'path\')\nconst VueLoaderPlugin = require(\'vue-loader/lib/plugin\')\n \nmodule.exports = {\n  mode: \'development\',\n  module: {\n    rules: [\n      {\n        test: /\\.vue$/,\n        loader: \'vue-loader\'\n      },\n    ]\n  },\n  plugins: [\n    new VueLoaderPlugin()\n  ]\n}\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n#其中也配置了mode，使其为开发模式development，这样在打包时就不会有warning了\n#继续打包依旧报错，提示需要vue-template-compiler\n#添加vue-template-compiler\nyarn add vue-template-compiler\n#打包，成功，打开index.html可以发现已经支持vue的语法了\nwebpack\n\n')])])]),s("h2",{attrs:{id:"五、vue-cli2-demo"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#五、vue-cli2-demo"}},[n._v("#")]),n._v(" 五、vue_cli2_demo")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("# VicUI >>>>>>> vue_cli2_demo\n#本demo为vue-cli2的学习过程\n#准备环境，安装前台开发所需环境（node.js、npm或者cnpm或者yarn、设置淘宝镜像等等）\n\n#####################################################################################\n\n#安装vue-cli2\nyarn init -y\n#-g表全局-D=--save--dev(开发阶段的依赖)\nyarn add vue-cli -gD\n#查看全局安装的路劲\nnpm root -g\n#查看安装结果（-V是大写）如果提示vue不是内部命令的话重启cmd即可\nvue -V\n\n#####################################################################################\n\n#创建vue-cli2项目\nvue init webpack projectName\n#projectName不能出现大写字母，一般可用小写字母加数字区分\n例如：vue init webpack test1\n#? Project name test1\n#? Project description A Vue.js project\n#? Author ship\n#? Vue build standalone\n#vue-router（）官方的路由：选择 Y\n#ESLint（官方代码管理工具，统一代码风格）：此处可选择 N\n#其余默认，一路回车，详细选择如下\n#install vue-router？是否安装vue的路由插件，需要就选y，否则就n（以下均遵循此方法）\n#Use ESLint to lint your code?是否使用ESLint检测你的代码？\n#（ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。）\n#Pick an ESLint preset:选择分支风格\n#选项有三个\n#1.standard(https://github.com/feross/standard) js的标准风格\n#2.Airbnb(https://github.com/airbnb/javascript) JavaScript最合理的方法，这个github地址说是JavaScript最合理的方法\n#3.none (configure it yourself) 自己配置\n#Setup unit tests? 是否安装单元测试（暂不详细介绍）\n#Pick a test runner 选择一个单元测试运行器\n#选项有三个（我选none）\n#1.Jest（Jest是由Facebook发布的开源的、基于Jasmine的JavaScript单元测试框架）\n#2.Karma and Mocha\n#3.none\n#Setup e2e tests with Nightwatch(Y/n)?是否安装E2E测试框架NightWatch（E2E，也就是End To End，就是所谓的“用户真实场景”。）\n#Should we run 'npm install' for you after the project has been created?(译：项目创建后是否要为你运行“npm install”?这里选择包管理工具)\n#选项有三个\n#yes,use npm(使用npm)\n#yes,use yarn(使用yarn)\n#no,I will handle that myself(自己操作)\n#一路回车到此等待安装完毕\n\n#创建完成后cd到test1下，执行yarn run dev\n#如果报错则在test1目录下执行yarn add vue-cli -gD后即可\n#访问http://localhost:8080项目成功\n\n#####################################################################################\n\n#项目练习，自己的hello world：新增First.vue页面\n#修改index.js,引入新增的页面：\nimport First from '@/components/First'\n#修改对应routes，查看页面发现已经改变\n\n#页面跳转\n#新建A.vue,B.vue(同A)\n<template>\n  <div>\n    <p>\n       我是A。。。。。。。。\n    </p>\n    <p>\n      <router-link to=\"/\">返回</router-link>\n    </p>\n  </div>\n</template>\n\n#修改First.vue\n<template>\n  <div>\n    <router-link to=\"/a\">转向A页面</router-link>\n    <router-link to=\"/b\">转向B页面</router-link>\n  </div>\n</template>\n\n#index.js配置路由\n#引入相应页面:\nimport A from '@/components/A'\nimport B from '@/components/B'\n{\n  path: '/a',\n  component: A\n},\n{\n  path: '/b',\n  component: B\n}\n\n#####################################################################################\n\n#嵌套路由效果：children;[{},{}]\n#一级组件跳转到二级组件，二级组件跳转到三级组件。。。。。。父子关系跳转\n#创建A1.vue\n<template>\n  <div>\n    <p>\n       我是A1。。。。。。。。\n    </p>\n    <p>\n      <router-link to=\"/a\">返回上一级</router-link>\n    </p>\n    <p>\n      <router-link to=\"/\">返回首页</router-link>\n    </p>\n  </div>\n</template>\n\n#注册路由\n#index.js\nimport A1 from '@/components/A1'\n{\n  path: '/a',\n  component: A,\n  children:[\n    {\n      path: '/A1',\n      component: A1\n    }\n  ]\n},\n\n#A.vue添加：\n<router-link to=\"/A1\">转向A1页面</router-link>\n#A转向A1，A作为父级页面，需要挂载子路由\n<router-view></router-view>\n#此时出现的效果是A转向A1后，父级跟子级页面的内容都会展现，因为A1配置为了A的children子页面\n#将A1更改为与A平级，路由配置去掉children\n{\n  path: '/a',\n  component: A\n},\n{\n  path: '/b',\n  component: B\n},\n{\n  path: '/A1',\n  component: A1\n}\n#查看页面跳转效果：A转向A1后不再显示A的内容\n#实现所有页面显示首页的内容\n#将A，B，A1页面的路由都配置在First的children里\nexport default new Router({\n  routes: [\n    {\n      path: '/',\n      name: 'First',\n      component: First,\n      children:[\n        {\n          path: '/a',\n          component: A\n        },\n        {\n          path: '/b',\n          component: B\n        },\n        {\n          path: '/A1',\n          component: A1\n        }\n      ]\n    }\n  ]\n})\n#First的div内挂载路由\n<router-view></router-view>\n#查看跳转效果：不管跳转到哪个页面都能看到首页内容\n\n#####################################################################################\n\n#为什么不用#号\n#目前为止我们跳转页面的时候会发现地址中带有#号：http://localhost:8080/#/A1\nhash模式：地址中带有#号，#号后的不被后台获取；\nhistory模式：具有对url历史记录进行修改的功能；\nurl需要传递参数时，#号不能满足需求；\nhistory需要后台配合，处理404的问题；\n#hash模式下，页面不存在不会抛404错误，只是点击没有反应，history模式下只要页面不存在就会抛404\n#history模式也可以控制对后台的访问操作，所以推荐使用history模式\n#index.js中添加路由模式\nexport default new Router({\n  mode: 'history',\n  routes: \n  ...\n#刷新页面再点击调整操作查看效果：不再有#号了\n\n#####################################################################################\n\n#单独安装eslint\n#如果诶有安装vue-router，单独安装\n#安装到生成环境\nyarn add eslint --save\n#安装到开发环境\nyarn add eslint --dev\nyarn add eslint --save-dev\nyarn add eslint -D\n#由于eslint是代码规范所以应该安装在开发环境，而不是生产环境\n#卸载\nyarn remove eslint\n#安装好后package.json配置中可以看到以下配置\n\"eslint\": \"^6.7.2\",\n#idea下打开的项目需要刷新项目文件才可以看见\n#基于webpack模板创建项目的语法\nvue init webpack prog1\n#####################################################################################\n\n")])])]),s("h2",{attrs:{id:"六、vue-cli3-demo"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#六、vue-cli3-demo"}},[n._v("#")]),n._v(" 六、vue_cli3_demo")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("# VicUI >>>> vue_cli3_demo\n#本Demo为vue_cli3的学习\n\n###########################################################################\n\n#vue_cli3的安装\n#卸载vue_cli2\nyarn remove vue_cli -g\nnpm uninstall vue_cli -g\n#安装的时候用的什么命令卸载的时候就用对应的命令\n#安装vue_cli3\nyarn add @vue/cli -gD\n#vue_cli3支持图形化界面创建项目\n#启动图像界面\nvue ui\n#进入地址即可访问\nhttp://localhost:8000/\n#命令行创建项目\nvue create test3\n#项目配置，不要选default\n Manually select features\n#暂时安装以下两项即可（初期学习不建议安装eslint）\n (*) Babel\n ( ) TypeScript\n ( ) Progressive Web App (PWA) Support\n (*) Router\n ( ) Vuex\n ( ) CSS Pre-processors\n>( ) Linter / Formatter\n ( ) Unit Testing\n ( ) E2E Testing\n#打Y选择history模式后回车即可\n#记录文件选择\n  In dedicated config files\n> In package.json\n回车再回车默认后续设置\n#启动命令\nyarn run serve\n#或者\nyarn serve\n#创建First.vue\n<template>\n    <div>\n        这是vue-cli3的第一个页面\n    </div>\n</template>\n\n#修改router下的index.js\nimport Vue from 'vue'\nimport VueRouter from 'vue-router'\nimport Home from '../views/Home.vue'\nimport First from '../components/First.vue'\n\nVue.use(VueRouter)\n\nconst routes = [\n  {\n    path: '/',\n    component: First\n  },\n  {\n    path: '/about',\n    name: 'about',\n    component: () => import(/* webpackChunkName: \"about\" */ '../views/About.vue')\n  }\n]\n\nconst router = new VueRouter({\n  mode: 'history',\n  base: process.env.BASE_URL,\n  routes\n})\n\nexport default router\n\n#查看页面效果\n\n###########################################################################\n\n#用cli3实现cli2的demo效果\n\n#更改First.vue\n<template>\n    <div>\n       <router-link to=\"/a\">转向A页面</router-link>\n       <router-link to=\"/b\">转向B页面</router-link>\n    </div>\n</template>\n\n#新增A.vue\n#新增B.vue\n#注册路由\nimport Vue from 'vue'\nimport VueRouter from 'vue-router'\nimport Home from '../views/Home.vue'\nimport First from '../components/First.vue'\nimport A from '../components/A.vue'\nimport B from '../components/B.vue'\n\nVue.use(VueRouter)\n\nconst routes = [\n  {\n    path: '/',\n    component: First\n  },\n  {\n    path: '/a',\n    component: A\n  },\n  {\n    path: '/b',\n    component: B\n  },\n  {\n    path: '/about',\n    name: 'about',\n    component: () => import(/* webpackChunkName: \"about\" */ '../views/About.vue')\n  }\n]\n\nconst router = new VueRouter({\n  mode: 'history',\n  base: process.env.BASE_URL,\n  routes\n})\n\nexport default router\n\n#此效果跳转不会显示主菜单，所以改成嵌套路由\nimport Vue from 'vue'\nimport VueRouter from 'vue-router'\nimport Home from '../views/Home.vue'\nimport First from '../components/First.vue'\nimport A from '../components/A.vue'\nimport B from '../components/B.vue'\n\nVue.use(VueRouter)\n\nconst routes = [\n  {\n    path: '/',\n    component: First,\n    children:[\n      {\n        path: '/a',\n        component: A\n      },\n      {\n        path: '/b',\n        component: B\n      }\n    ]\n  },\n  {\n    path: '/about',\n    name: 'about',\n    component: () => import(/* webpackChunkName: \"about\" */ '../views/About.vue')\n  }\n]\n\nconst router = new VueRouter({\n  mode: 'history',\n  base: process.env.BASE_URL,\n  routes\n})\n\nexport default router\n\n#挂载路由First.vue\n<router-view></router-view>\n#或者\n<router-view/>\n\n#查看效果\n\n###########################################################################\n\n#样式\n#router-link属于a标签\n#First.vue添加\n<style>\n  a{\n    color:red;\n    font-size: 20px;\n  }\n</style>\n#或者添加对应class\n<template>\n    <div>\n       <router-link class=\"ys1\" to=\"/a\">转向A页面</router-link>\n       <router-link class=\"ys1\" to=\"/b\">转向B页面</router-link>\n      <router-view/>\n    </div>\n</template>\n<style>\n  .ys1{\n    color:red;\n    font-size: 20px;\n  }\n</style>\n\n#此种设置属于内部样式\n#外部样式设置\n#外部样式要写在public里面\n#新建ys1.css\n#引入外部样式\n  @import \"../../public/ys1.css\";\n#注意返回的层级数：First.vue的上一级为components，再上一级为src，src才是跟public同级，所以返回了两层\n#如果需要更高级别的样式控制，也可以将样式加在index.html里\n<link rel=\"stylesheet\" type=\"text/css\" href=\"ys1.css\">\n\n#刷新首页生效\n\n\n\n")])])]),s("h2",{attrs:{id:"七、vue-cli3-proj"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#七、vue-cli3-proj"}},[n._v("#")]),n._v(" 七、vue_cli3_proj")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("# VicUI >>>> vue_cli3_proj\n#vue_cli3练习项目\n\n###########################################################################\n\n#vue_cli3的安装\n#卸载vue_cli2\nyarn remove vue_cli -g\nnpm uninstall vue_cli -g\n#安装的时候用的什么命令卸载的时候就用对应的命令\n#安装vue_cli3\nyarn add @vue/cli -gD\n#vue_cli3支持图形化界面创建项目\n#启动图像界面\nvue ui\n#进入地址即可访问\nhttp://localhost:8000/\n#命令行创建项目\nvue create proj\n#项目配置，不要选default\n Manually select features\n#暂时安装以下两项即可（初期学习不建议安装eslint）\n (*) Babel\n ( ) TypeScript\n ( ) Progressive Web App (PWA) Support\n (*) Router\n ( ) Vuex\n ( ) CSS Pre-processors\n>( ) Linter / Formatter\n ( ) Unit Testing\n ( ) E2E Testing\n#打Y选择history模式后回车即可\n#记录文件选择\n  In dedicated config files\n> In package.json\n回车再回车默认后续设置\n#启动命令\nyarn run serve\n#或者\nyarn serve\n\n")])])])])}),[],!1,null,null,null);e.default=a.exports}}]);